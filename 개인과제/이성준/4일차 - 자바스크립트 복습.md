1.  자바스크립트 기본 문법

변수의 선언(var/let/const)

자바스크립트의 번수의 선언은 3가지로 구성이 되어있다. 그중에서 현재 안정성을 이유로 상수를 선언할 때는 const, 변수는 let으로 선언한다  
var의 경우 변수가 생성되는 과정이 선언과 초기화가 동시에 일어나고 이후 할당이 일어난다. 이렇기 때문에 var를 여러번 재선언을 할 수 있게 되는 오류가 발생한다. 또한 scope도 hoisting과정에서 최상단에 해당 변수가 선언이 되기 때문에 변수의 범위가 local이 아닌 전역변수처럼 사용되는 경우가 많아 안정적이지 않다  
반면 const와 let의 경우 선언과 초기화, 할당 단계로 나누어서 진행이 된다. 그렇기에 hoisting 과정에서 최상단에 변수의 형태만을 선언하고 초기화를 실제 변수의 선언문을 만났을 떄에만 수행하기 떄문에 값이 지역 범위에서만 사용할 수 있게 되는것이다.  
const의 경우 배열을 선언시 배열 내부의 원소는 수정할 수 있다.

변수의 타입  
변수의 타입은 크게 Number, String, Boolean, Undefined, Null로 나눌 수 있다.  
Number의 경우 일반적인 숫자를 모두 포함하는 형태(int, long, short, byte, float, double)이다. 또한 String과 Boolean 도 마찬가지이다.  
자바스크립트는 특이하게 변수의 할당이 되지 않은 상태를 undefined로 규정한다. 이는 자바스크립트의 형태가 let과 같이 유연하게 사용하기에 나오는 현상이다. 또한 아예 값이 없음을 명시적으로 표현하기 위해 null이라는 자료형도 사용한다.  
그 외에도 객체의 경우 Object, 배열은 Array를 사용한다. 콘솔에서 null을 출력할 때는 null Object 형태로 출력이 된다.

number에서는 해당 값이 숫자가 아님을 표현하고자 "NaN(not a number)"를 별도로 두고 있다. 이를 참고하여 타입 오류를 잡을 수 있다.

조건문  
다른 언어와 마찬가지로 if ~ else if ~ else문, switch문을 제공한다.  
그러나 JS의 경우 조건문의 판별기준으로 truthy, falsy를 제공한다. 이는 C언어 계열의 판정과 유사하게 boolean 자료형이 아니더라도 결과를 내놓을 수 있는 형태이다. 예를 들어 양수 또는 문자열이면 truthy인데, 만약 숫자가 0이거나 빈 문자열의 경우에는 falsy로 판별이 되는 형태이다.  
또한 두 변수가 같음을 확인하기 위한 비교 연산자는 등호가 2개가 있는 경우는 형태가 같음을 확인하고, 등호가 3개가 있는 형태는(===) 타입과 값이 모두 일치하는 경우에만 true로 판별한다.

반복문  
다른 프로그래밍 언어와 마찬가지로 for문과 while문, foreach문을 제공한다. for문은 초기 조건, 종료 조건, 스텝과 같은 형태, 배열의 경우 for ~ in 구문을 제공한다.  
그 외에도 forEach 문과 배열의 map을 이용한 반복도 가능한데, 다음과 같은 형태로 배열의 원소를 호출할 수 있다.

```
arr.forEach(function(item, i) {
    console.log(i, item);
});

const returnArr = arr.map(function(item) {
    return item;
});
```

얕은 복사와 깊은 복사  
문자열과 숫자와 같은 경우 이를 복사할 때 값이 그대로 복사가 된다. 그러나 배열과 같은 경우 복사를 할때는 값 자체가 아닌 주소값을 복사하는 얕은 복사 형태로 값이 전달이 되기 떄문에 이를 유의해야한다.  
해결을 위해서는 JSON.parse 메서드를 활용하여 값 자체를 복사하거나 외부 라이브러릴 사용하는 방법이 있다.

정렬  
자바스크립트에서도 기본적인 정렬함수를 제공한다. 그러나 별도의 정렬 함수를 선언해주지 않으면 문자열의 ASCII 코드를 기준으로 정렬하기에 유의해야한다. 즉, 숫자를 넣어도 사전순으로 정렬이 된다.  
이를 해결하기 위해서 별도의 정렬함수를 다음과 같이 선언하여 사용한다

```
function(o1,o2) {
    return o1-o2;
});
```

## 2\. 함수

### 간단한 함수

자바스크립트에서 함수의 형태는 다음과 같다

```
function func(param1, param2){
    return param1 + param2;
};
```

또는 화살표 함수로 이를 줄일 수 있다. Javascript에서 화살표는 (=>) 형태를 사용한다

```
    const res = (a,b) => (a+b);
```

파라미터와 오버로딩  
자바스크립트의 함수 파라미터의 경우, 함수의 정의와 다르게 파라미터의 개수를 다르게 설정하더라도 문제가 되지 않는다.

```
function func(param1, param2)
```

다음과 같은 함수를 사용할 때 파라미터가 1개를 넣을 때는 뒤의 결과가 undefined로 사용이 되고, 만약 해당 함수에 파라미터를 3개를 넣었을 경우에는 뒤에 나오는 세번째 인자가 무시가 된다.  
또한 가변 인자를 사용할 수 있는데, 이는 "..."으로 표시하여 사용한다

```
function func(...params)
```

주의할 점은 다른 프로그래밍 언어와 다르게 함수 오버로딩이 되지않는다. 구체적으로는 오류가 발생하는 것이 아닌 가장 마지막에 정의한 함수로 덮어씌워진다.

import/export  
export와 import를 하는경우, 이를 명시적으로 표현하기 위해 메서드 앞에 export 키워드를 통해 이를 export할 수 있다. 또한 default 키워드로 이를 다른 JS 파일에서 다양한 형태로 사용할 수 있다. 단, default는 한 파일에 1개만 허용한다.  
이를 import하는 경우 다음과 같은 형식으로 불러올 수 있다.

```
import {func1, func2, func3} from js;
```

CDN  
Content Delivery Network로 이는 말그대로 파일을 빠르게 전달해주는 네트워크이다. 이는 외부에 있는 스크립트를 실행시켜주는 것으로 설치해서 사용하는 라이브러리는 아니다. 이를 통해 외부 기능 혹은 폰트 등을 적용할 수 있다.  
또한 CDN으로 jQuery를 호출하여 사용할 수 있다. jQuery의 주 기능으로는 DOM 조작, 이벤트 처리, AJAX 요청, 애니메이션 효과, 브라우저 호환성 보장 등의 기능을 제공한다. (현재는 다른 프레임워크로 대체)

3.  API 통신

fetch  
JSON과 같은 API를 가져오기 위해 사용하는 구문이다. fetch(file).then.catch와 같이 사용한다  
이때 then 구문의 경우 documentGetElementById와 같은 구문으로 JSON의 속성을 가공하여 사용할 수 있다. catch의 경우 일반적인 프로그래밍 언어와 같이 예외처리를 할 때 사용한다

async ~ await  
비동기적으로 데이터를 받아오는 기존 방식은 fetch ~ then 코드를 사용했으나, 만약 불러오는 데이터가 지나치게 많이 중첩이 되어있는 상태라면 코드의 가독성이 심하게 떨어지는 callback Hell이 발생한다. 이를 해결하기 위해 async ~ await 구문을 이용하여 데이터를 비동기적으로 불러올 수 있다. 이렇게 불러온다면 가독성 뿐만 아니라 데이터를 순차적으로 불러올 수 있다.