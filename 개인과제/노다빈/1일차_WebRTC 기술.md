# WebRTC 기술

WebRTC(Web Real-Time Communication)는 웹 브라우저 간에 플러그인 없이 실시간으로 음성, 영상 및 데이터를 주고받을 수 있도록 하는 오픈소스 프로젝트이자 웹 표준 기술입니다. 이 기술은 웹 기반의 고품질 실시간 통신 애플리케이션 개발을 가능하게 하며, 팬데믹 이후 비대면 상호작용의 중요성이 커지면서 그 활용도가 더욱 증대되고 있습니다.

---

## 1. WebRTC 소개

WebRTC는 단순한 커뮤니케이션 기술을 넘어, 다양한 산업 분야에서 혁신을 이끌어내는 핵심 인프라 기술로 자리매김하고 있습니다. **낮은 지연 시간**과 **강력한 보안**을 바탕으로 사용자에게 끊김 없는 실시간 경험을 제공하며, 웹 표준 기술이므로 **별도의 플러그인 설치 없이** 즉시 사용할 수 있다는 큰 장점을 가집니다.

- **P2P 기반 통신**: 서버를 거치지 않고 브라우저 간 직접 연결을 시도하여 빠른 속도를 제공합니다.
- **플러그인 불필요**: 웹 브라우저 자체에서 실시간 통신 기능을 제공합니다.
- **보안성**: HTTPS가 강제되며, DTLS(Datagram Transport Layer Security)를 통해 암호화된 통신을 제공합니다.
- **다양한 미디어 및 데이터 지원**: 음성, 영상뿐만 아니라 임의의 데이터(텍스트, 파일 등) 교환도 가능합니다.
- **NAT/방화벽 우회**: STUN/TURN 서버를 활용하여 NAT(Network Address Translation) 및 방화벽 환경에서도 P2P 연결을 시도합니다.

---

## 2. WebRTC 아키텍처 및 구성 요소

WebRTC는 단순히 클라이언트 간의 직접 연결만을 의미하지 않습니다. 안정적인 실시간 통신을 위해서는 여러 핵심 구성 요소들이 유기적으로 결합하여 동작합니다.

### 2.1. 핵심 API

- `getUserMedia()`: 사용자의 카메라, 마이크 등 미디어 장치에 접근하여 오디오 및 비디오 스트림을 가져오는 API입니다.
- `RTCPeerConnection`: 두 피어(Peer) 간의 P2P 연결을 설정하고 관리하는 핵심 API입니다. 시그널링, 코덱 협상, P2P 통신, 보안(암호화), 대역폭 관리 등 WebRTC 통신의 대부분을 담당합니다.
- `RTCDataChannel`: 피어 간 양방향 임의 데이터 통신을 위한 채널을 제공하는 API입니다. 미디어 스트림(음성, 영상) 외의 데이터를 저지연으로 주고받을 때 사용됩니다.

### 2.2. 필수 서버

- **시그널링 서버 (Signaling Server)**: 피어 간의 연결 정보(네트워크 정보, 미디어 설정 등)를 교환하는 중개 서버입니다. 실제 미디어 데이터를 중개하지는 않으며, SDP(Session Description Protocol)와 ICE Candidate 정보를 교환하는 데 사용됩니다. WebSocket 등 다양한 방식으로 구현될 수 있습니다.
- **STUN 서버 (Session Traversal Utilities for NAT)**: NAT(Network Address Translation) 환경에서 클라이언트의 공인 IP 주소와 NAT 타입을 찾아주어 ICE Candidate를 생성하는 데 도움을 줍니다. P2P 직접 연결을 돕는 보조 서버 역할을 합니다.
- **TURN 서버 (Traversal Using Relays around NAT)**: STUN 서버를 통해서도 P2P 직접 연결이 불가능할 경우(예: 대칭형 NAT, 엄격한 방화벽), 미디어 데이터를 중계하는 릴레이 서버 역할을 합니다. 가장 높은 비용을 발생시키므로 최후의 수단으로 사용됩니다.

### 2.3. 주요 프로토콜

- **SDP (Session Description Protocol)**: 미디어 세션의 정보를 기술하는 표준 프로토콜입니다. 오디오/비디오 코덱, 해상도, 대역폭, 전송 프로토콜 등 미디어 통신에 필요한 메타데이터를 정의하는 데 사용됩니다.
- **ICE (Interactive Connectivity Establishment)**: 두 피어 간의 최적의 통신 경로를 찾는 프레임워크입니다. STUN/TURN 서버를 활용하여 다양한 네트워크 환경에서 P2P 연결을 시도합니다. 'ICE Candidate'는 통신을 위한 잠재적인 네트워크 경로 후보들을 의미합니다.
- **SRTP (Secure Real-time Transport Protocol)**: 실시간 미디어 데이터(RTP)를 암호화하여 보안을 강화하는 프로토콜입니다.
- **DTLS (Datagram Transport Layer Security)**: UDP 기반의 통신을 암호화하는 프로토콜로, WebRTC에서 시그널링 외의 다른 데이터(ICE, SCTP)의 보안을 담당합니다.
- **SCTP (Stream Control Transmission Protocol)**: WebRTC 데이터 채널을 통해 오디오/비디오 외의 임의의 데이터를 전송할 때 사용되는 프로토콜입니다.

---

## 3. WebRTC 연결 과정 (Signaling & ICE)

WebRTC의 연결 과정은 복잡해 보이지만, 크게 시그널링과 ICE 후보 교환의 두 단계로 나눌 수 있습니다.

1.  **미디어 장치 접근**: `getUserMedia()`를 통해 로컬 오디오/비디오 스트림을 확보합니다.
2.  **RTCPeerConnection 생성**: 통신에 사용할 `RTCPeerConnection` 객체를 생성합니다.
3.  **Offer/Answer 교환 (시그널링)**:
    - 통화를 시작하는 피어(Caller)가 `createOffer()`를 호출하여 자신의 미디어 정보를 담은 SDP Offer를 생성합니다.
    - 생성된 Offer를 `setLocalDescription()`으로 설정한 후, 시그널링 서버를 통해 상대방 피어(Callee)에게 전달합니다.
    - Callee는 Offer를 `setRemoteDescription()`으로 받은 후, 자신의 미디어 정보와 함께 `createAnswer()`를 호출하여 SDP Answer를 생성합니다.
    - Answer를 `setLocalDescription()`으로 설정하고 시그널링 서버를 통해 Caller에게 전달합니다.
    - Caller는 Answer를 `setRemoteDescription()`으로 받으면, 양방향 미디어 협상이 완료됩니다.
4.  **ICE Candidate 교환 (시그널링)**:
    - `RTCPeerConnection` 객체가 생성되는 순간부터 ICE 프레임워크는 로컬 네트워크 정보를 수집하여 통신 가능한 경로 후보(ICE Candidates)를 찾습니다.
    - STUN 서버를 통해 자신의 공인 IP 주소를 얻거나, 필요시 TURN 서버를 통해 릴레이 주소를 얻습니다.
    - 수집된 ICE Candidate들은 `icecandidate` 이벤트 콜백을 통해 시그널링 서버로 전송되고, 상대방에게도 전달됩니다 (`addIceCandidate()`).
5.  **P2P 연결 설정**: 모든 SDP와 ICE Candidate 교환이 완료되면, ICE 프레임워크는 수집된 후보들을 바탕으로 최적의 경로를 탐색하고 직접적인 P2P 연결을 시도합니다. 연결이 성공하면 미디어 스트림이 양방향으로 직접 흐르기 시작합니다.

---

## 4. 다자간 통화 아키텍처 (Mesh, SFU, MCU)

WebRTC는 기본적으로 1:1 P2P 통신에 최적화되어 있지만, 다자간 통화 구현을 위해 세 가지 주요 아키텍처가 활용됩니다. 각 아키텍처는 클라이언트 및 서버 부하, 지연 시간, 확장성 등에서 다른 특징을 가집니다.

- **Mesh (Full Mesh)**:

  - **개념**: 모든 참가자가 다른 모든 참가자와 직접 P2P 연결을 맺는 방식입니다.
  - **장점**: 서버 부하가 매우 낮고, 지연 시간이 가장 짧습니다.
  - **단점**: 참가자 수 증가 시 클라이언트 부하(CPU, 대역폭)가 급격히 증가합니다 (N명의 참가자가 N-1개의 업로드/다운로드 스트림 처리). 확장성이 매우 제한적입니다.
  - **적합**: 1:1 또는 3\~4명 이하의 소규모 그룹 통화.

- **SFU (Selective Forwarding Unit)**:

  - **개념**: 각 참가자가 자신의 미디어 스트림을 중앙 SFU 서버로 전송하고, SFU 서버는 이 스트림들을 받아 다른 참가자들에게 선택적으로 전달(Forwarding)합니다. 미디어 가공(Mixing/Transcoding)은 하지 않습니다.
  - **장점**: Mesh보다 클라이언트 부하가 적고, 뛰어난 확장성을 제공합니다 (클라이언트는 N개의 스트림을 수신하지만, N-1개만 송신). 유연한 레이아웃 제어가 가능합니다.
  - **단점**: Mesh보다 서버 부하가 높으며, 서버 인프라 구축 및 운영 비용이 발생합니다.
  - **적합**: 대부분의 현대 화상 회의 서비스 (Zoom, Google Meet 등), 1:N 라이브 스트리밍, 수십 명 규모의 그룹 통화.

- **MCU (Multipoint Control Unit)**:

  - **개념**: 모든 미디어 스트림을 중앙 MCU 서버가 받아 하나로 합성(Mixing)하거나 변환(Transcoding)한 후, 단일 스트림으로 각 참가자에게 다시 전송합니다.
  - **장점**: 클라이언트 부하가 매우 낮고(단일 스트림만 송수신), 대규모 통화에 가장 적합합니다. 다양한 미디어 포맷 간 변환이 가능합니다.
  - **단점**: 매우 높은 서버 부하를 가지며, 미디어 처리로 인해 지연이 발생할 수 있습니다. 서버 인프라 비용이 가장 높고 구현이 복잡합니다.
  - **적합**: 대규모 웨비나, 고정된 레이아웃의 컨퍼런스, 다양한 클라이언트 환경 지원이 필요한 경우.

---

## 5. WebRTC 개발 환경 및 디버깅

WebRTC 개발은 JavaScript 기반으로 이루어지며, 웹 브라우저에서 직접 구현됩니다.

- **브라우저 호환성**: 대부분의 최신 웹 브라우저(Chrome, Firefox, Safari, Edge)는 WebRTC를 지원합니다. 하지만 브라우저별 API 접두사나 구현의 미묘한 차이가 있을 수 있는데, 이를 위해 `adapter.js`와 같은 라이브러리를 사용하여 크로스 브라우징 호환성을 확보할 수 있습니다.
- **시그널링 서버**: WebRTC 자체는 시그널링 방식을 정의하지 않으므로, 개발자가 Node.js (Socket.io), Python, Java 등 원하는 언어와 프레임워크를 사용하여 시그널링 서버를 구축해야 합니다.
- **STUN/TURN 서버**: 개발 및 테스트 단계에서는 Google의 공개 STUN 서버(stun:https://www.google.com/search?q=stun.l.google.com:19302)를 사용할 수 있습니다. 상용 서비스에서는 안정적인 전용 STUN/TURN 서버(Coturn 등)를 구축하거나 클라우드 서비스(AWS Kinesis Video Streams, Twilio 등)를 이용합니다.
- **디버깅 도구**: Chrome 브라우저의 `chrome://webrtc-internals`와 같은 내장 도구는 WebRTC 연결 상태, 스트림 통계, ICE 후보 교환 과정 등 상세한 정보를 제공하여 개발자가 문제를 진단하고 성능을 최적화하는 데 필수적입니다.

---

## 6. WebRTC의 장점, 한계점 및 활용 사례

### 6.1. 장점

- **낮은 지연 시간**: P2P 직접 연결을 통해 서버 중개를 최소화하여 실시간성에 매우 유리합니다.
- **플러그인 불필요**: 웹 브라우저 자체 기능으로 제공되어 사용자 접근성이 높고 설치 번거로움이 없습니다.
- **개발 용이성**: 표준화된 API를 통해 웹 개발자가 쉽게 실시간 통신 기능을 구현할 수 있습니다.
- **오픈소스 & 무료**: 라이선스 비용 없이 자유롭게 사용할 수 있습니다.

### 6.2. 한계점

- **NAT/방화벽 문제**: 복잡한 네트워크 환경에서는 STUN/TURN 서버 없이는 연결이 어렵습니다. TURN 서버 사용 시 비용이 발생합니다.
- **크로스 브라우징**: 브라우저별 API 구현 차이로 인해 호환성 문제가 발생할 수 있으며, `adapter.js` 등으로 보완해야 합니다.
- **시그널링 표준 부재**: 시그널링 방식이 표준화되어 있지 않아 개발자가 직접 구현해야 하는 부담이 있습니다.
- **확장성**: 대규모 다자간 통화 시 Mesh 아키텍처의 한계로 인해 SFU/MCU 서버 구축이 필수적이며, 이는 인프라 복잡성 및 비용 증가로 이어집니다.

### 6.3. 다양한 활용 사례

WebRTC는 비디오 컨퍼런싱을 넘어 다양한 분야에서 혁신적인 서비스를 가능하게 합니다.

- **화상 회의 및 영상 통화**: Google Meet, Zoom, Microsoft Teams 등 대다수 서비스의 핵심 기술로 활용됩니다.
- **음성 기반 통신**: Clubhouse, Discord 등 음성 채팅 및 오디오 기반 소셜 앱.
- **라이브 스트리밍 및 방송**: 저지연 라이브 커머스, 스포츠 중계, 온라인 교육 등.
- **게임 및 원격 제어**: 클라우드 게이밍, 원격 로봇 제어, 산업용 장비 모니터링 및 제어 (NCSoft Yeti).
- **헬스케어**: 원격 진료, 디지털 상담, 의료진 간 실시간 협업.
- **IoT (사물 인터넷)**: 스마트 홈 기기(CCTV 등)의 실시간 영상 스트리밍, 기기 간 직접 통신.
- **데이터 공유**: 대용량 파일 P2P 공유, 실시간 문서 협업.

---

## 7. WebRTC 기술의 최신 동향 및 미래 발전 방향

WebRTC 시장은 2024년 79.6억 달러에서 2034년 1891.6억 달러 규모로 성장할 것으로 예측(CAGR 37.28%)되는 등 폭발적인 성장세를 보이고 있습니다. 이는 원격 근무 확산, 원격 의료 수요 증가, BYOD(Bring Your Own Device) 트렌드, 5G 기술 발전 등의 요인이 복합적으로 작용한 결과입니다.

미래 WebRTC 기술은 다음과 같은 방향으로 발전할 것입니다.

- **5G 네트워크와의 시너지**: 5G의 초저지연, 초고속, 초연결 특성은 WebRTC의 성능을 극대화하여 끊김 없는 고품질 실시간 통신 환경을 제공할 것입니다.
- **AI (인공지능)와의 통합**: 실시간 음성/영상 분석, 자동 번역, 노이즈 캔슬링, 얼굴 인식, 감정 분석 등 AI 기반 기능들이 WebRTC 통신에 접목되어 사용자 경험을 혁신할 것입니다.
- **VR/AR (가상/증강현실)과의 융합**: 메타버스 환경에서 사용자 간의 몰입형 상호작용 및 협업을 위한 핵심 통신 기술로 활용될 가능성이 높습니다.
- **IoT (사물 인터넷) 장치 지원 확대**: 스마트 홈, 산업용 IoT 장치 등과의 실시간 통신을 통해 원격 모니터링 및 제어 분야에서 활용이 더욱 확대될 것입니다.
- **보안 및 프라이버시 강화**: 실시간 통신의 민감한 특성을 고려하여, 더욱 강력한 암호화 및 보안 메커니즘이 발전할 것입니다.
- **표준화 및 상호 운용성 강화**: W3C와 IETF를 통한 지속적인 표준화 작업은 WebRTC의 호환성과 안정성을 높여 다양한 플랫폼 및 기기 간의 seamless한 통신을 가능하게 할 것입니다.
